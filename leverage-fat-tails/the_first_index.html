<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Leverage & Fat Tails Option Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- (Optionnel) une Google Font simple -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #0f172a;
      --bg-elevated: #111827;
      --card-bg: #020617;
      --border-subtle: #1f2937;
      --accent: #38bdf8;
      --accent-soft: rgba(56,189,248,0.12);
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --radius-lg: 14px;
      --shadow-soft: 0 18px 40px rgba(15,23,42,0.65);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at top, #1f2937 0, #020617 45%, #020617 100%);
      color: var(--text-main);
    }

    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 24px 16px 48px;
    }

    .site-header {
      border-bottom: 1px solid #1f2937;
      background: rgba(15,23,42,0.9);
      backdrop-filter: blur(8px);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .header-inner {
      max-width: 1100px;
      margin: 0 auto;
      padding: 14px 16px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }

    .site-header h1 {
      font-size: 1.1rem;
      margin: 0 0 4px;
    }

    .header-subtitle {
      margin: 0;
      font-size: 0.8rem;
      color: var(--text-muted);
      max-width: 600px;
    }

    .header-nav {
      display: flex;
      gap: 12px;
      font-size: 0.85rem;
    }

    .header-nav a {
      color: var(--text-muted);
      text-decoration: none;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid transparent;
    }

    .header-nav a:hover {
      color: var(--accent);
      border-color: var(--accent-soft);
      background: rgba(15,23,42,0.9);
    }

    .section {
      margin-top: 28px;
      padding: 18px 20px;
      background: linear-gradient(135deg, rgba(15,23,42,0.96), rgba(2,6,23,0.98));
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      box-shadow: var(--shadow-soft);
    }

    .section-text {
      line-height: 1.6;
      font-size: 0.93rem;
    }

    .section h2 {
      margin-top: 0;
      margin-bottom: 8px;
      font-size: 1.1rem;
    }

    .section p {
      margin-top: 6px;
      margin-bottom: 6px;
    }

    .section-intro {
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .equation {
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.9rem;
      padding: 8px 10px;
      border-radius: 8px;
      background: #020617;
      border: 1px solid #1f2937;
      display: inline-block;
      margin: 8px 0;
    }

    .section ul {
      margin: 6px 0 6px 18px;
      padding-left: 0;
    }

    .section li {
      margin-bottom: 4px;
    }

    .lab-layout {
      margin-top: 10px;
    }

    /* Tu peux garder / adapter tes styles existants pour .container, .panel, etc. */
    .container {
      display: grid;
      grid-template-columns: minmax(260px, 320px) minmax(0, 1fr);
      gap: 14px;
    }

    .panel {
      background: #020617;
      border-radius: 12px;
      border: 1px solid #1f2937;
      padding: 12px 14px;
    }

    .panel.left h2,
    .panel.right h2 {
      margin-top: 0;
      font-size: 0.95rem;
    }

    .panel label {
      display: block;
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-top: 6px;
      margin-bottom: 2px;
    }

    .panel input,
    .panel select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #1f2937;
      background: #020617;
      color: var(--text-main);
      font-size: 0.82rem;
    }

    .panel input:focus,
    .panel select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.3);
    }

    #run-btn {
      margin-top: 10px;
      width: 100%;
      padding: 8px 10px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(to right, #38bdf8, #22c55e);
      color: #0b1120;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
    }

    #run-btn:hover {
      filter: brightness(1.06);
    }

    .result-box {
      border-radius: 10px;
      border: 1px solid #1f2937;
      background: #020617;
      padding: 8px 10px;
      font-size: 0.82rem;
    }

    .metrics-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 4px;
      font-size: 0.82rem;
    }

    .metrics-table td {
      padding: 3px 4px;
      border-bottom: 1px solid #111827;
    }

    .metrics-table tr:last-child td {
      border-bottom: none;
    }

    .gauge-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
    }

    .gauge-label {
      width: 135px;
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .gauge-bar {
      flex: 1;
      height: 8px;
      border-radius: 999px;
      background: #020617;
      border: 1px solid #111827;
      overflow: hidden;
    }

    .gauge-fill {
      height: 100%;
      background: linear-gradient(to right, #38bdf8, #22c55e);
      width: 0%;
      transition: width 0.5s ease;
    }

    .heatmap-grid {
      display: grid;
      gap: 4px;
      margin-top: 6px;
      font-size: 0.78rem;
    }

    .heatmap-header-cell,
    .heatmap-row-label,
    .heatmap-cell {
      padding: 4px 6px;
      border-radius: 4px;
      text-align: center;
    }

    .heatmap-header-cell {
      font-weight: 500;
      background: #020617;
      border: 1px solid #1f2937;
    }

    .heatmap-row-label {
      text-align: left;
      font-weight: 500;
      background: #020617;
      border: 1px solid #1f2937;
    }

    .heatmap-cell {
      border: 1px solid rgba(15,23,42,0.6);
    }

    .heatmap-legend {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-top: 6px;
    }

    .chart-container {
      position: relative;
      height: 220px;
      margin-top: 8px;
    }

    .site-footer {
      border-top: 1px solid #1f2937;
      padding: 10px 0 16px;
      margin-top: 16px;
      background: #020617;
    }

    .footer-inner {
      max-width: 1100px;
      margin: 0 auto;
      padding: 0 16px;
      font-size: 0.78rem;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    @media (max-width: 800px) {
      .header-inner {
        flex-direction: column;
        align-items: flex-start;
      }
      .container {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <header class="site-header">
    <div class="header-inner">
      <div>
        <h1>Leverage, Liquidations & Left Tails</h1>
		<p class="header-subtitle">
 		 An interactive exploration of how diffuse leverage shapes return distributions, 
		  tail risk, and option prices.
		</p>

      </div>
      <nav class="header-nav">
        <a href="#intro">Intuition</a>
        <a href="#macro-model">Macro Model</a>
        <a href="#lab">Interactive Lab</a>
      </nav>
    </div>
  </header>

  <main class="page">
    <!-- Section 1 : Intuition -->
<section id="intro" class="section section-text">
  <h2>Intuition & Stylized Facts</h2>
  <p>
    Financial returns are not Gaussian. Markets usually exhibit long periods of small, 
    moderately positive returns, punctuated by sudden, sharp crashes. This pattern — 
    mild upside drift and rare but violent downside moves — cannot be captured by a 
    classical Brownian motion.
  </p>
  <p>
    A key driver of this asymmetry is <strong>diffuse leverage</strong>: many small 
    agents borrow in order to increase their exposure. As long as prices remain stable 
    or rise, leverage creates additional demand and pushes returns slightly upward.
    However, once prices drop enough to reach <em>margin</em> or <em>liquidation</em> 
    thresholds, forced selling triggers cascades of liquidations, producing disproportionately 
    large negative returns.
  </p>
  <p>
    This mechanism naturally generates:
  </p>
  <ul>
    <li><strong>More small positive returns</strong> than negative ones (daily leverage build-up),</li>
    <li><strong>Thicker left tails</strong> (crashes caused by liquidation cascades),</li>
    <li><strong>Negative skewness</strong> and <strong>high kurtosis</strong>.</li>
  </ul>
</section>

    <!-- Section 2 : Macro model -->
    <section id="macro-model" class="section section-text">
  <h2>Macro Model: Aggregate Leverage & Crash Dynamics</h2>
  <p>
    The idea can be captured by a simple return process where the log-return 
    <code>R<sub>t+1</sub></code> is composed of a regular “calm” component plus a potential 
    liquidation shock:
  </p>

  <p class="equation">
    R<sub>t+1</sub> = μ<sub>L</sub>(L<sub>t</sub>) + σ<sub>0</sub> ε<sub>t+1</sub> + C<sub>t+1</sub>
  </p>

  <ul>
    <li><strong>L<sub>t</sub></strong>: aggregate market leverage.</li>
    <li>
      <strong>μ<sub>L</sub>(L<sub>t</sub>) = μ<sub>0</sub> + β L<sub>t</sub></strong>: 
      a leverage-dependent drift capturing the slight upward bias induced by leverage.
    </li>
    <li><strong>σ<sub>0</sub> ε<sub>t+1</sub></strong>: a fundamental Gaussian shock.</li>
    <li>
      <strong>C<sub>t+1</sub></strong>: a rare negative liquidation shock whose probability 
      increases with leverage L<sub>t</sub>.
    </li>
  </ul>

  <p>
    Under this structure, higher aggregate leverage mechanically produces:
  </p>

  <ul>
    <li><strong>Positive expected returns</strong> (accumulation phase),</li>
    <li><strong>Heavy left tails</strong> (liquidation cascades),</li>
    <li><strong>More skewness</strong> (asymmetry),</li>
    <li><strong>More kurtosis</strong> (extreme events become frequent).</li>
  </ul>

  <p>
    The interactive lab below illustrates these effects by comparing a classical 
    Gaussian risk-neutral world with heavy-tailed models (Student-t) and a stylized 
    leverage-dependent asymmetric model that amplifies negative tail risk.
  </p>
</section>

    <!-- Section 3 : Lab -->
    <section id="lab" class="section">
  <h2>Leverage & Fat Tails Exploration Lab</h2>
  <p class="section-intro">
    Use predefined scenarios or adjust parameters to compare
    <strong>Black–Scholes</strong>,
    a <strong>heavy-tailed Student-t model</strong>,
    and a <strong>Student-t + leverage model</strong>.
    Observe how leverage and tail risk affect option prices, the return
    distribution, VaR/ES, liquidation probability, and the distortion surface
    relative to Black–Scholes.
  </p>

    <div class="container">
      <!-- LEFT PANEL -->
      <div class="panel left">
        <h2>Scenario</h2>
        <select id="scenario" style="width: 100%; margin-bottom: 8px;">
          <option value="manual">Manual (user-defined)</option>
          <option value="calm">Calm market</option>
          <option value="fat_tails">Heavy tails</option>
          <option value="stress">High leverage stress</option>
        </select>

        <h2>Model Parameters</h2>

        <label for="spot">Spot price S₀</label>
        <input id="spot" type="number" value="100" />

        <label for="strike">Strike K</label>
        <input id="strike" type="number" value="100" />

        <label for="maturity">Maturity T (years)</label>
        <input id="maturity" type="number" step="0.1" value="1" />

        <label for="rate">Risk-free rate r</label>
        <input id="rate" type="number" step="0.01" value="0.02" />

        <label for="vol">Volatility σ</label>
        <input id="vol" type="number" step="0.01" value="0.2" />

        <label for="sliq">Liquidation threshold S<sub>liq</sub></label>
        <input id="sliq" type="number" step="1" value="70" />

        <label for="model">Model</label>
        <select id="model">
          <option value="gaussian" selected>Gaussian (Black–Scholes)</option>
          <option value="student">Student-t (heavy tails)</option>
          <option value="student_leverage">Student-t + leverage effect</option>
        </select>

        <label for="nu">Degrees of freedom ν (Student-t)</label>
        <input id="nu" type="number" step="1" value="5" min="3" max="50" />

        <label for="L">Leverage multiplier L</label>
        <input id="L" type="number" step="0.5" value="2" min="1" max="10" />

        <label for="alpha">Leverage sensitivity α</label>
        <input id="alpha" type="number" step="0.1" value="0.5" min="0" max="2" />

        <label for="nsims">Number of simulations (MC)</label>
        <input id="nsims" type="number" step="1000" value="5000" />

        <button id="run-btn">Run simulation</button>
      </div>

      <!-- RIGHT PANEL -->
      <div class="panel right">
        <h2>Results</h2>
        <div class="result-box" id="results">
          Click “Run simulation” to compute prices and show the return distribution.
        </div>

        <h2 style="margin-top: 8px;">Return distribution (histogram)</h2>
        <p style="font-size: 0.85rem; color: #6b7280; margin-top: 4px;">
          Simulated percentage returns for the selected model (clipped to the [-80%, +80%] range).
        </p>
        <div style="height: 260px; margin-bottom: 12px;">
          <canvas id="returnsChart" style="width: 100%; height: 100%;"></canvas>
        </div>

        <h2 style="margin-top: 8px;">Risk metrics</h2>
        <div class="result-box" id="riskMetrics">
          Run a simulation to display mean, volatility, skewness, kurtosis, VaR and Expected Shortfall.
        </div>

        <h2 style="margin-top: 8px;">Liquidation risk</h2>
        <div class="result-box" id="liquidationBox">
          Set a liquidation threshold S<sub>liq</sub> and run a simulation to estimate liquidation
          probabilities under different models.
        </div>

        <h2 style="margin-top: 8px;">Smile & term-structure distortion (heatmap)</h2>
        <p style="font-size: 0.85rem; color: #6b7280; margin-top: 4px;">
          Colour = Call(Student-t + leverage) – Call(Black–Scholes), by moneyness (K/S₀) and maturity T.
        </p>
        <div class="result-box" id="heatmap">
          Select the Student-t + leverage model and run a simulation to display the heatmap.
        </div>

        <h2 style="margin-top: 16px;">Call price comparison</h2>
        <p style="font-size: 0.85rem; color: #6b7280; margin-top: 4px;">
          Black–Scholes analytic vs Monte Carlo models (same inputs, Call option).
        </p>
        <div style="height: 220px; margin-bottom: 12px;">
          <canvas id="priceChart" style="width: 100%; height: 100%;"></canvas>
        </div>
      </div>
    </div>
  </div>
</section>


  <footer class="site-footer">
    <div class="footer-inner">
      <span>Leverage &amp; Fat Tails — Research Sandbox</span>
    </div>
  </footer>


<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

     <script>
    // ---------- Random helpers ----------

    function randNormal() {
      let u1 = 0, u2 = 0;
      while (u1 === 0) u1 = Math.random();
      while (u2 === 0) u2 = Math.random();
      const R = Math.sqrt(-2.0 * Math.log(u1));
      const theta = 2.0 * Math.PI * u2;
      return R * Math.cos(theta); // ~ N(0,1)
    }

    function randStudentT(nu) {
      if (nu < 3) nu = 3;
      if (nu > 50) nu = 50;

      const Z = randNormal();

      let sumSq = 0;
      const k = Math.floor(nu);
      for (let i = 0; i < k; i++) {
        const z = randNormal();
        sumSq += z * z;
      }
      const U = sumSq; // ~ Chi-square(k)

      return Z / Math.sqrt(U / nu);
    }

    // ---------- Black–Scholes helper functions ----------

    function normCdf(x) {
      const a1 = 0.254829592;
      const a2 = -0.284496736;
      const a3 = 1.421413741;
      const a4 = -1.453152027;
      const a5 = 1.061405429;
      const p = 0.3275911;

      const sign = x < 0 ? -1 : 1;
      const absX = Math.abs(x) / Math.sqrt(2.0);

      const t = 1.0 / (1.0 + p * absX);
      const y =
        1.0 -
        (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-absX * absX);

      return 0.5 * (1.0 + sign * y);
    }

    function blackScholesCall(S, K, r, sigma, T) {
      if (T <= 0 || sigma <= 0) {
        return Math.max(S - K, 0);
      }
      const sqrtT = Math.sqrt(T);
      const d1 = (Math.log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrtT);
      const d2 = d1 - sigma * sqrtT;
      return S * normCdf(d1) - K * Math.exp(-r * T) * normCdf(d2);
    }

    function blackScholesPut(S, K, r, sigma, T) {
      const call = blackScholesCall(S, K, r, sigma, T);
      return call - S + K * Math.exp(-r * T);
    }

    // ---------- Monte Carlo pricing engines ----------

    function priceCallPutMCGaussian(S0, K, r, sigma, T, nSims = 5000) {
      const disc = Math.exp(-r * T);
      const sqrtT = Math.sqrt(T);

      let sumCall = 0, sumPut = 0, sumST = 0;

      for (let i = 0; i < nSims; i++) {
        const Z = randNormal();
        const R = (r - 0.5 * sigma * sigma) * T + sigma * sqrtT * Z;
        const ST = S0 * Math.exp(R);

        sumCall += Math.max(ST - K, 0);
        sumPut  += Math.max(K - ST, 0);
        sumST   += ST;
      }

      return {
        callMC: Math.exp(-r * T) * (sumCall / nSims),
        putMC:  Math.exp(-r * T) * (sumPut  / nSims),
        meanST: sumST / nSims
      };
    }

    function priceCallPutMCStudentT(S0, K, r, sigma, T, nu, nSims = 5000) {
      const disc = Math.exp(-r * T);
      const sqrtT = Math.sqrt(T);

      let sumCall = 0, sumPut = 0, sumST = 0;

      if (!Number.isFinite(nu) || nu < 3) nu = 5;
      if (nu > 50) nu = 50;

      for (let i = 0; i < nSims; i++) {
        const Zt = randStudentT(nu);
        const R = (r - 0.5 * sigma * sigma) * T + sigma * sqrtT * Zt;
        const ST = S0 * Math.exp(R);

        sumCall += Math.max(ST - K, 0);
        sumPut  += Math.max(K - ST, 0);
        sumST   += ST;
      }

      return {
        callMC: disc * (sumCall / nSims),
        putMC:  disc * (sumPut  / nSims),
        meanST: sumST / nSims
      };
    }

    function priceCallPutMCStudentTLeverage(S0, K, r, sigma, T, nu, L, alpha, nSims = 5000) {
      const disc = Math.exp(-r * T);
      const sqrtT = Math.sqrt(T);

      let sumCall = 0, sumPut = 0, sumST = 0;

      if (!Number.isFinite(nu) || nu < 3) nu = 5;
      if (nu > 50) nu = 50;
      if (!Number.isFinite(L) || L < 1) L = 1;
      if (L > 10) L = 10;
      if (!Number.isFinite(alpha) || alpha < 0) alpha = 0;
      if (alpha > 2) alpha = 2;

      for (let i = 0; i < nSims; i++) {
        const Zt = randStudentT(nu);

        const R_brut = (r - 0.5 * sigma * sigma) * T + sigma * sqrtT * Zt;
        let sigmaEff = sigma;
        if (R_brut < 0) {
          sigmaEff = sigma * (1 + alpha * L);
        }

        const R = (r - 0.5 * sigmaEff * sigmaEff) * T + sigmaEff * sqrtT * Zt;
        const ST = S0 * Math.exp(R);

        sumCall += Math.max(ST - K, 0);
        sumPut  += Math.max(K - ST, 0);
        sumST   += ST;
      }

      return {
        callMC: disc * (sumCall / nSims),
        putMC:  disc * (sumPut  / nSims),
        meanST: sumST / nSims
      };
    }

    // ---------- Histogram & returns simulation ----------

    function simulateReturnsForHistogram(model, S0, r, sigma, T, nu, L, alpha, nHist) {
      const sqrtT = Math.sqrt(T);
      const returns = [];

      if (!Number.isFinite(nHist) || nHist <= 0) nHist = 2000;
      if (!Number.isFinite(nu) || nu < 3) nu = 5;
      if (nu > 50) nu = 50;
      if (!Number.isFinite(L) || L < 1) L = 2;
      if (L > 10) L = 10;
      if (!Number.isFinite(alpha) || alpha < 0) alpha = 0.5;
      if (alpha > 2) alpha = 2;

      for (let i = 0; i < nHist; i++) {
        let ST;

        if (model === "gaussian") {
          const Z = randNormal();
          const R = (r - 0.5 * sigma * sigma) * T + sigma * sqrtT * Z;
          ST = S0 * Math.exp(R);
        } else if (model === "student") {
          const Zt = randStudentT(nu);
          const R = (r - 0.5 * sigma * sigma) * T + sigma * sqrtT * Zt;
          ST = S0 * Math.exp(R);
        } else if (model === "student_leverage") {
          const Zt = randStudentT(nu);
          const R_brut = (r - 0.5 * sigma * sigma) * T + sigma * sqrtT * Zt;
          let sigmaEff = sigma;
          if (R_brut < 0) {
            sigmaEff = sigma * (1 + alpha * L);
          }
          const R = (r - 0.5 * sigmaEff * sigmaEff) * T + sigmaEff * sqrtT * Zt;
          ST = S0 * Math.exp(R);
        } else {
          const Z = randNormal();
          const R = (r - 0.5 * sigma * sigma) * T + sigma * sqrtT * Z;
          ST = S0 * Math.exp(R);
        }

        const simpleReturn = ST / S0 - 1;
        returns.push(simpleReturn);
      }

      return returns;
    }

    function buildHistogram(data, numBins = 40) {
      const min = -0.8;
      const max =  0.8;
      const binWidth = (max - min) / numBins;
      const counts = new Array(numBins).fill(0);

      for (const r of data) {
        let x = Math.max(min, Math.min(max, r));
        let idx = Math.floor((x - min) / binWidth);
        if (idx < 0) idx = 0;
        if (idx >= numBins) idx = numBins - 1;
        counts[idx]++;
      }

      const labels = [];
      for (let i = 0; i < numBins; i++) {
        const center = min + (i + 0.5) * binWidth;
        labels.push((center * 100).toFixed(1) + "%");
      }

      return { labels, counts };
    }

    let returnsChart = null;
    let priceChart   = null;

    function updateReturnsChart(returnsArray) {
      const { labels, counts } = buildHistogram(returnsArray, 40);
      const ctx = document.getElementById("returnsChart").getContext("2d");

      if (!returnsChart) {
        returnsChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: labels,
            datasets: [{ label: "Simulated returns (frequency)", data: counts }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                ticks: { autoSkip: true, maxTicksLimit: 10 },
                title: { display: true, text: "Return (percent, binned)" }
              },
              y: {
                title: { display: true, text: "Frequency" }
              }
            },
            plugins: { legend: { display: false } }
          }
        });
      } else {
        returnsChart.data.labels = labels;
        returnsChart.data.datasets[0].data = counts;
        returnsChart.update();
      }
    }

    function updatePriceChart(callBS, callGauss, callStudent, callLev) {
      const ctx = document.getElementById("priceChart").getContext("2d");
      const labels = ["BS analytic", "Gaussian MC", "Student-t MC", "Student+Leverage MC"];
      const data = [callBS, callGauss, callStudent, callLev];

      if (!priceChart) {
        priceChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: labels,
            datasets: [{ label: "Call price", data: data }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { title: { display: true, text: "Model" } },
              y: { title: { display: true, text: "Call price" } }
            },
            plugins: { legend: { display: false } }
          }
        });
      } else {
        priceChart.data.labels = labels;
        priceChart.data.datasets[0].data = data;
        priceChart.update();
      }
    }

    // ---------- Risk metrics ----------

    function computeRiskMetrics(returnsArray, varLevel = 0.99) {
      const n = returnsArray.length;
      if (!n) return null;

      let sum = 0;
      for (const x of returnsArray) sum += x;
      const mean = sum / n;

      let sumSq = 0;
      for (const x of returnsArray) {
        const d = x - mean;
        sumSq += d * d;
      }
      const variance = sumSq / n;
      const std = Math.sqrt(variance);

      let skew = 0, kurt = 0;
      if (std > 0) {
        for (const x of returnsArray) {
          const z = (x - mean) / std;
          skew += z ** 3;
          kurt += z ** 4;
        }
        skew /= n;
        kurt /= n;
      }

      const sorted = [...returnsArray].sort((a, b) => a - b);
      const tailProb = 1 - varLevel;
      const idx = Math.max(0, Math.min(n - 1, Math.floor(tailProb * n)));
      const varReturn = sorted[idx];
      const esSlice = sorted.slice(0, idx + 1);
      let esMean = varReturn;
      if (esSlice.length > 0) {
        let esSum = 0;
        for (const x of esSlice) esSum += x;
        esMean = esSum / esSlice.length;
      }

      const varLoss = -varReturn;
      const esLoss = -esMean;

      return { mean, std, skew, kurt, varLoss, esLoss };
    }

    // ---------- Liquidation probabilities ----------

    function computeLiquidationProbabilities(S0, Sliq, r, sigma, T, nu, L, alpha, nSims) {
      if (!Number.isFinite(Sliq) || Sliq <= 0) return null;
      if (!Number.isFinite(nSims) || nSims <= 0) nSims = 10000;

      const sqrtT = Math.sqrt(T);

      let countGauss = 0;
      let countStudent = 0;
      let countLev = 0;

      if (!Number.isFinite(nu) || nu < 3) nu = 5;
      if (nu > 50) nu = 50;
      if (!Number.isFinite(L) || L < 1) L = 2;
      if (L > 10) L = 10;
      if (!Number.isFinite(alpha) || alpha < 0) alpha = 0.5;
      if (alpha > 2) alpha = 2;

      for (let i = 0; i < nSims; i++) {
        // Gaussian
        {
          const Z = randNormal();
          const R = (r - 0.5 * sigma * sigma) * T + sigma * sqrtT * Z;
          const ST = S0 * Math.exp(R);
          if (ST <= Sliq) countGauss++;
        }

        // Student-t
        {
          const Zt = randStudentT(nu);
          const R = (r - 0.5 * sigma * sigma) * T + sigma * sqrtT * Zt;
          const ST = S0 * Math.exp(R);
          if (ST <= Sliq) countStudent++;
        }

        // Student-t + leverage
        {
          const Zt2 = randStudentT(nu);
          const R_brut = (r - 0.5 * sigma * sigma) * T + sigma * sqrtT * Zt2;
          let sigmaEff = sigma;
          if (R_brut < 0) {
            sigmaEff = sigma * (1 + alpha * L);
          }
          const R = (r - 0.5 * sigmaEff * sigmaEff) * T + sigmaEff * sqrtT * Zt2;
          const ST = S0 * Math.exp(R);
          if (ST <= Sliq) countLev++;
        }
      }

      return {
        pGauss:   countGauss   / nSims,
        pStudent: countStudent / nSims,
        pLev:     countLev     / nSims
      };
    }

    // ---------- Heatmap: Student+Leverage vs BS ----------

    const heatmapDiv = document.getElementById("heatmap");

    function generateHeatmap(S0, r, sigma, nu, L, alpha) {
      if (!heatmapDiv) return;

      const moneynessLevels = [0.8, 0.9, 1.0, 1.1, 1.2];
      const maturityLevels  = [0.25, 0.5, 1.0, 2.0];

      const nHeatSims = 8000; // compromis stabilité / vitesse

      const data = [];
      let minDiff = Infinity;
      let maxDiff = -Infinity;

      for (let j = 0; j < maturityLevels.length; j++) {
        const T = maturityLevels[j];
        const row = [];
        for (let i = 0; i < moneynessLevels.length; i++) {
          const m = moneynessLevels[i];
          const K = S0 * m;

          const callBS = blackScholesCall(S0, K, r, sigma, T);
          const resLev = priceCallPutMCStudentTLeverage(S0, K, r, sigma, T, nu, L, alpha, nHeatSims);

          const diff = resLev.callMC - callBS;
          row.push(diff);

          if (diff < minDiff) minDiff = diff;
          if (diff > maxDiff) maxDiff = diff;
        }
        data.push(row);
      }

      renderHeatmap(data, moneynessLevels, maturityLevels, minDiff, maxDiff);
    }

    function renderHeatmap(data, mLevels, tLevels, minDiff, maxDiff) {
      if (!heatmapDiv) return;

      if (!isFinite(minDiff) || !isFinite(maxDiff) || maxDiff === minDiff) {
        heatmapDiv.textContent = "Unable to compute heatmap (distortion range is degenerate).";
        return;
      }

      const rows = tLevels.length;
      const cols = mLevels.length;
      const gridCssColumns = `auto repeat(${cols}, 1fr)`;

      let html = `<div class="heatmap-grid" style="grid-template-columns:${gridCssColumns};">`;

      html += `<div></div>`;
      for (let i = 0; i < cols; i++) {
        html += `<div class="heatmap-header-cell">K/S₀ = ${mLevels[i].toFixed(1)}</div>`;
      }

      for (let j = 0; j < rows; j++) {
        const T = tLevels[j];
        html += `<div class="heatmap-row-label">T = ${T}y</div>`;

        for (let i = 0; i < cols; i++) {
          const val = data[j][i];

          const norm = (val - minDiff) / (maxDiff - minDiff);
          const hue = 210 - 210 * norm;      // bleu -> rouge
          const lightness = 85 - 35 * norm;  // plus foncé si distorsion forte
          const bg = `hsl(${hue}, 80%, ${lightness}%)`;

          html += `<div class="heatmap-cell" style="background:${bg};">
                     ${val.toFixed(2)}
                   </div>`;
        }
      }

      html += `
        </div>
        <div class="heatmap-legend">
          Values are Call(Student-t + leverage) – Call(BS).<br/>
          Blue ≈ small distortion, red ≈ strong increase vs Black–Scholes.
        </div>`;

      heatmapDiv.innerHTML = html;
    }

    // ---------- UI wiring & scenarios ----------

    const button         = document.getElementById("run-btn");
    const resultsDiv     = document.getElementById("results");
    const riskMetricsDiv = document.getElementById("riskMetrics");
    const liquidationBox = document.getElementById("liquidationBox");
    const scenarioSelect = document.getElementById("scenario");

    function applyScenario(name) {
      const spotInput     = document.getElementById("spot");
      const strikeInput   = document.getElementById("strike");
      const maturityInput = document.getElementById("maturity");
      const rateInput     = document.getElementById("rate");
      const volInput      = document.getElementById("vol");
      const modelSelect   = document.getElementById("model");
      const nuInput       = document.getElementById("nu");
      const LInput        = document.getElementById("L");
      const alphaInput    = document.getElementById("alpha");
      const nsimsInput    = document.getElementById("nsims");
      const sliqInput     = document.getElementById("sliq");

      if (name === "manual") {
        return;
      }

      if (name === "calm") {
        spotInput.value     = 100;
        strikeInput.value   = 100;
        maturityInput.value = 1.0;
        rateInput.value     = 0.01;
        volInput.value      = 0.15;
        modelSelect.value   = "gaussian";
        nuInput.value       = 20;
        LInput.value        = 1;
        alphaInput.value    = 0.2;
        nsimsInput.value    = 20000;
        sliqInput.value     = 70;
      } else if (name === "fat_tails") {
        spotInput.value     = 100;
        strikeInput.value   = 100;
        maturityInput.value = 1.0;
        rateInput.value     = 0.02;
        volInput.value      = 0.20;
        modelSelect.value   = "student";
        nuInput.value       = 5;
        LInput.value        = 1;
        alphaInput.value    = 0.0;
        nsimsInput.value    = 20000;
        sliqInput.value     = 70;
      } else if (name === "stress") {
        spotInput.value     = 100;
        strikeInput.value   = 100;
        maturityInput.value = 1.0;
        rateInput.value     = 0.02;
        volInput.value      = 0.25;
        modelSelect.value   = "student_leverage";
        nuInput.value       = 5;
        LInput.value        = 3;
        alphaInput.value    = 0.8;
        nsimsInput.value    = 25000;
        sliqInput.value     = 70;
      }

      if (button) button.click();
    }

    if (scenarioSelect) {
      scenarioSelect.addEventListener("change", () => {
        applyScenario(scenarioSelect.value);
      });
    }

    // ---------- Main button handler ----------

    button.addEventListener("click", () => {
      const S0    = Number(document.getElementById("spot").value);
      const K     = Number(document.getElementById("strike").value);
      const T     = Number(document.getElementById("maturity").value);
      const r     = Number(document.getElementById("rate").value);
      const sigma = Number(document.getElementById("vol").value);
      const Sliq  = Number(document.getElementById("sliq").value);
      const model = document.getElementById("model").value;

      let nu    = Number(document.getElementById("nu").value);
      let L     = Number(document.getElementById("L").value);
      let alpha = Number(document.getElementById("alpha").value);
      let nSims = Number(document.getElementById("nsims").value);

      if (!Number.isFinite(nu) || nu < 3) nu = 5;
      if (nu > 50) nu = 50;
      if (!Number.isFinite(L) || L < 1) L = 2;
      if (L > 10) L = 10;
      if (!Number.isFinite(alpha) || alpha < 0) alpha = 0.5;
      if (alpha > 2) alpha = 2;
      if (!Number.isFinite(nSims) || nSims <= 0) nSims = 10000;

      if (S0 <= 0 || K <= 0 || T < 0 || sigma < 0) {
        resultsDiv.textContent = "Please enter positive values for S0, K, T and sigma.";
        return;
      }

      const callBS = blackScholesCall(S0, K, r, sigma, T);
      const putBS  = blackScholesPut(S0, K, r, sigma, T);

      let callMC, putMC, meanST;
      let mcDescription = "";

      if (model === "gaussian") {
        const res = priceCallPutMCGaussian(S0, K, r, sigma, T, nSims);
        callMC = res.callMC;
        putMC  = res.putMC;
        meanST = res.meanST;
        mcDescription = "Gaussian Monte Carlo (same assumptions as Black–Scholes)";
      } else if (model === "student") {
        const res = priceCallPutMCStudentT(S0, K, r, sigma, T, nu, nSims);
        callMC = res.callMC;
        putMC  = res.putMC;
        meanST = res.meanST;
        mcDescription = `Student-t Monte Carlo (ν = ${nu})`;
      } else if (model === "student_leverage") {
        const res = priceCallPutMCStudentTLeverage(S0, K, r, sigma, T, nu, L, alpha, nSims);
        callMC = res.callMC;
        putMC  = res.putMC;
        meanST = res.meanST;
        mcDescription = `Student-t + leverage Monte Carlo (ν = ${nu}, L = ${L}, α = ${alpha})`;
      }

      const theoMeanST = S0 * Math.exp(r * T);

      let warningText = "";
      if (model === "gaussian") {
        warningText =
          `Simulated E[S_T] under this model: ${meanST.toFixed(4)}\n` +
          "In a risk-neutral Gaussian world, this should be close to the theoretical value.\n";
      } else {
        warningText =
          `Simulated E[S_T] under this model: ${meanST.toFixed(4)}\n` +
          "⚠ This is a stylized heavy-tailed / leverage stress model, not strictly risk-neutral.\n";
      }

      // ----- Bloc Results (tableau + jauge) -----
      resultsDiv.innerHTML = `
        <strong>Pricing results</strong>
        <div style="font-size: 0.85rem; color: #6b7280; margin-top: 2px;">
          Model: <code>${model}</code> – ${mcDescription}
        </div>
        <table class="metrics-table">
          <tbody>
            <tr>
              <td>Analytic Call (BS)</td>
              <td>${callBS.toFixed(4)}</td>
            </tr>
            <tr>
              <td>Analytic Put (BS)</td>
              <td>${putBS.toFixed(4)}</td>
            </tr>
            <tr>
              <td>MC Call (N=${nSims})</td>
              <td>${callMC.toFixed(4)}</td>
            </tr>
            <tr>
              <td>MC Put (N=${nSims})</td>
              <td>${putMC.toFixed(4)}</td>
            </tr>
            <tr>
              <td colspan="2">
                <div class="gauge-row">
                  <div class="gauge-label">Risk-neutral E[S<sub>T</sub>]</div>
                  <div class="gauge-bar">
                    <div id="gauge-bs" class="gauge-fill"></div>
                  </div>
                </div>
                <div class="gauge-row">
                  <div class="gauge-label">Simulated E[S<sub>T</sub>]</div>
                  <div class="gauge-bar">
                    <div id="gauge-model" class="gauge-fill"></div>
                  </div>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
        <div style="font-size: 0.8rem; white-space: pre-line; margin-top: 4px;">
          ${warningText}
        </div>
        <div style="font-size: 0.8rem; color: #6b7280; margin-top: 4px;">
          Inputs: S0=${S0}, K=${K}, T=${T}, r=${r}, σ=${sigma}, ν=${nu}, L=${L}, α=${alpha}, N=${nSims}
        </div>
      `;

      // Jauge E[S_T]
      const bsMean    = theoMeanST;
      const modelMean = meanST;
      const maxValue  = Math.max(bsMean, modelMean) * 1.1;
      const bsPct     = Math.min(100, (bsMean / maxValue) * 100);
      const modelPct  = Math.min(100, (modelMean / maxValue) * 100);
      document.getElementById("gauge-bs").style.width     = bsPct + "%";
      document.getElementById("gauge-model").style.width  = modelPct + "%";

      // ----- Graphique comparaison de prix -----
      const nPriceSims = Math.min(nSims, 15000);
      const gaussResForChart   = priceCallPutMCGaussian(S0, K, r, sigma, T, nPriceSims);
      const studentResForChart = priceCallPutMCStudentT(S0, K, r, sigma, T, nu, nPriceSims);
      const levResForChart     = priceCallPutMCStudentTLeverage(S0, K, r, sigma, T, nu, L, alpha, nPriceSims);

      updatePriceChart(
        callBS,
        gaussResForChart.callMC,
        studentResForChart.callMC,
        levResForChart.callMC
      );

      // ----- Histogramme des rendements -----
      const nHist = Math.min(5000, nSims);
      const returnsArray = simulateReturnsForHistogram(model, S0, r, sigma, T, nu, L, alpha, nHist);
      updateReturnsChart(returnsArray);

      // ----- Risk metrics -----
      const metrics = computeRiskMetrics(returnsArray, 0.99);
      if (metrics) {
        const toPct = (x) => (x * 100).toFixed(2) + "%";
        riskMetricsDiv.innerHTML = `
          <strong>Risk metrics based on simulated simple returns (annual horizon)</strong>
          <table class="metrics-table">
            <tbody>
              <tr>
                <td>Mean</td>
                <td>${toPct(metrics.mean)}</td>
              </tr>
              <tr>
                <td>Std dev</td>
                <td>${toPct(metrics.std)}</td>
              </tr>
              <tr>
                <td>Skewness</td>
                <td>${metrics.skew.toFixed(3)}</td>
              </tr>
              <tr>
                <td>Kurtosis</td>
                <td>${metrics.kurt.toFixed(3)}</td>
              </tr>
              <tr>
                <td>VaR 99% (loss)</td>
                <td>${toPct(metrics.varLoss)}</td>
              </tr>
              <tr>
                <td>ES 99% (loss)</td>
                <td>${toPct(metrics.esLoss)}</td>
              </tr>
            </tbody>
          </table>
        `;
      } else {
        riskMetricsDiv.textContent = "Not enough data to compute risk metrics.";
      }

      // ----- Liquidation risk -----
      if (liquidationBox && Number.isFinite(Sliq) && Sliq > 0) {
        const nSimsLiquidation = Math.min(25000, Math.max(8000, Math.floor(nSims || 10000)));
        const liq = computeLiquidationProbabilities(S0, Sliq, r, sigma, T, nu, L, alpha, nSimsLiquidation);

        if (liq) {
          const toPct = (x) => (x * 100).toFixed(2) + "%";
          liquidationBox.innerHTML = `
            <strong>Probability of liquidation (S<sub>T</sub> ≤ S<sub>liq</sub>)</strong>
            <table class="metrics-table">
              <tbody>
                <tr>
                  <td>Gaussian</td>
                  <td>${toPct(liq.pGauss)}</td>
                </tr>
                <tr>
                  <td>Student-t (ν = ${nu})</td>
                  <td>${toPct(liq.pStudent)}</td>
                </tr>
                <tr>
                  <td>Student-t + leverage</td>
                  <td>${toPct(liq.pLev)}</td>
                </tr>
              </tbody>
            </table>
          `;
        } else {
          liquidationBox.textContent = "Unable to compute liquidation probabilities (check S_liq).";
        }
      } else if (liquidationBox) {
        liquidationBox.textContent = "Set a positive liquidation threshold S_liq to compute probabilities.";
      }

      // ----- Heatmap -----
      if (model === "student_leverage") {
        heatmapDiv.textContent = "Computing heatmap...";
        setTimeout(() => {
          generateHeatmap(S0, r, sigma, nu, L, alpha);
        }, 10);
      } else {
        heatmapDiv.textContent =
          "Heatmap is defined for the Student-t + leverage model (difference vs Black–Scholes). Select that model to see the distortion.";
      }
    });
  </script>
  
</body>
</html>
